# Daily Coding Challenge - 2026-01-14

*Auto-generated by AI Bot v4.0*

# Challenge: Sort Colors (Dutch National Flag Problem)

## Problem
Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the standard library's sort function.

**Example:**
Input: `nums = [2, 0, 2, 1, 1, 0]`
Output: `[0, 0, 1, 1, 2, 2]`

## Solution
```python
def sortColors(nums: list[int]) -> None:
    """
    Sorts an array containing 0s, 1s, and 2s in-place.
    This algorithm is also known as the Dutch National Flag problem.
    """
    low, mid, high = 0, 0, len(nums) - 1 # Initialize three pointers

    while mid <= high: # Iterate while the mid pointer is within bounds
        if nums[mid] == 0:
            # If current element is 0, swap it with the element at 'low'.
            # This moves 0s to the beginning.
            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1 # Advance 'low' pointer to mark the end of 0s section
            mid += 1 # Advance 'mid' pointer to next element
        elif nums[mid] == 1:
            # If current element is 1, it's already in its correct relative position.
            # Just move 'mid' pointer forward.
            mid += 1
        else: # nums[mid] == 2
            # If current element is 2, swap it with the element at 'high'.
            # This moves 2s to the end.
            nums[high], nums[mid] = nums[mid], nums[high]
            high -= 1 # Retreat 'high' pointer to mark the start of 2s section
            # Important: Do not increment 'mid' here. The swapped element at nums[mid]
            # could be 0, 1, or 2 and needs to be re-evaluated in the next iteration.
```

## Analysis
- Time Complexity: O(n)
- Space Complexity: O(1)

## Explanation
The solution employs the "Dutch National Flag" algorithm, which is an in-place sorting algorithm particularly efficient for sorting an array of elements with three distinct values (like 0, 1, and 2).

It uses three pointers:
1.  `low`: Points to the next position where a 0 should be placed. Elements to its left (`0` to `low-1`) are all 0s.
2.  `mid`: The current element being examined. Elements between `low` and `mid-1` are all 1s.
3.  `high`: Points to the next position where a 2 should be placed. Elements to its right (`high+1` to `n-1`) are all 2s.

The `mid` pointer iterates through the array.
- If `nums[mid]` is 0: It is swapped with `nums[low]`. Both `low` and `mid` pointers are incremented. This expands the section of 0s at the beginning.
- If `nums[mid]` is 1: It is already in its correct place relative to 0s and 2s. Only `mid` is incremented.
- If `nums[mid]` is 2: It is swapped with `nums[high]`. The `high` pointer is decremented. Crucially, `mid` is **not** incremented because the new element swapped into `nums[mid]` might be a 0, 1, or 2 and needs to be re-evaluated.

This process continues until `mid` crosses `high`, resulting in a single pass over the array and sorting it in-place.
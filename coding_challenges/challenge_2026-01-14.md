# Daily Coding Challenge - 2026-01-14

*Auto-generated by AI Bot v4.0*

# Challenge: Binary Tree Zigzag Level Order Traversal

## Problem
Given the `root` of a binary tree, return the *zigzag level order traversal* of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).

For example:
Input: root = [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
Output: [[3],[20,9],[15,7]]

## Solution
```python
import collections

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzag_level_order(root: TreeNode) -> list[list[int]]:
    if not root:
        return []

    result = []
    # Use a deque for efficient appends/pops from both ends (BFS)
    queue = collections.deque([root]) 
    left_to_right = True # Flag to alternate traversal direction

    while queue:
        level_size = len(queue)
        current_level_vals = []
        
        # Process all nodes at the current level
        for _ in range(level_size):
            node = queue.popleft() # Dequeue node from left
            current_level_vals.append(node.val)
            
            # Enqueue children for the next level
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        # Reverse the list if traversing right to left for this level
        if not left_to_right:
            current_level_vals.reverse()
        
        result.append(current_level_vals) # Add current level's values to result
        left_to_right = not left_to_right # Toggle direction for the next level
        
    return result
```

## Analysis
- Time Complexity: O(N), where N is the number of nodes in the binary tree. Each node is visited and processed exactly once.
- Space Complexity: O(N), where N is the number of nodes. In the worst case (a complete binary tree), the queue can hold up to N/2 nodes at the widest level. The `result` list also stores all N node values.

## Explanation
The solution uses a breadth-first search (BFS) approach, implemented with a `collections.deque` for efficient additions and removals. It processes the tree level by level.
A boolean flag `left_to_right` is used to track the current traversal direction, starting with `True` for the root level.
In each iteration of the `while` loop, all nodes at the current level are processed:
1. Their values are added to a temporary `current_level_vals` list.
2. Their children are enqueued for the next level.
After processing all nodes of a level, if `left_to_right` is `False` (meaning the current level should be traversed right-to-left), the `current_level_vals` list is reversed. Finally, this list is appended to the `result`, and the `left_to_right` flag is toggled for the next level, ensuring the alternating zigzag pattern.